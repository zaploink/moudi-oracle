<!DOCTYPE html>
<html>
  <head>
    <title>Example: Overpass-API with Leaflet.js</title>
  	<meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.0.3/dist/leaflet.css" />
    <style>
      body {
        padding: 0;
        margin: 0;
      }
      html, body, #map {
        height: 100%;
        width: 100%;
      }
      #overpass-api-controls {
        padding: 10px;
        background-color: rgb(255, 255, 255);
      }
      #overpass-api-controls a {
        display: inline;
      }
    </style>
  </head>
  <body>
    <div id="map">

      <div class="leaflet-control-container">
        <div class="leaflet-top leaflet-right">
          <div id="overpass-api-controls" class="leaflet-bar leaflet-control">
            <span>Tramline: </span>
            <select id="tram-selector">
              <option id="-1"></option>
            </select>
          </div>
        </div>
      </div>

    </div>

    <script src="https://unpkg.com/leaflet@1.6.0/dist/leaflet.js"></script>
    <script src="https://code.jquery.com/jquery-3.4.1.min.js"></script>
    <script src="https://unpkg.com/osmtogeojson@2.2.12/osmtogeojson.js"></script>

    <script>
      const overpassUrl = 'http://overpass.osm.ch/api/interpreter?data=';
      var tramsByNumber;

      function start() {
        // get all tramlines from overpass
        const query = `[out:json];
          area[name="ZÃ¼rich"];
          relation[route=tram][ref](area)->.trams;
          foreach.trams (
            convert rel
	          ::id = u(id()),
	          name = u(t["name"]),
              from = u(t["from"]),
              to = u(t["to"]),
              ref = u(t["ref"]);
            out;
          )`.replace(/\s+/g, " ");
        const url = overpassUrl + query; encodeURIComponent(query);
        console.debug(url);
        $.get(url, function(result) {
          console.debug(`Query returned ${result.elements.length} tram relations`);
          tramsByNumber = new Map();
          for (let tram of result.elements) {
            tramsByNumber.set(tram.tags.ref, tram); // last one wins
          }
          console.debug(`Mapped to a total of ${tramsByNumber.size} tram lines`);
          console.debug(tramsByNumber);
          populateTramSelector();
        });
      }

      function populateTramSelector() {
        for (var i=2; i<=17; i++) { // skip 16, does not exist
          const tram = tramsByNumber.get(i.toString());
          if (tram) {
            $('#tram-selector').append(`<option value="${i}">${tram.tags.name}</option>`);
          }
        };
      }

      function loadRouteAndRestaurants(tramId) {
        console.debug(`Loading route and restaurants for tram #${tramId}`);
        const tram = tramsByNumber.get(tramId);
        const query = `[out:json];
          rel(id:2807094);
          ._->.tram;
          way(r.tram)[railway=tram];
          ._->.tracks;
          node(r.tram)[railway=tram_stop];
          ._->.stops;
          nwr[amenity=restaurant](around:100);
          ._->.stopRest;
          .tram;
          nwr[amenity=restaurant](around:20);
          ._->.tramRest;
          node.tramRest.stopRest;
          ._->.candidates;
          (
            .tram;
            .stops;
            .candidates;
          );
          out geom;
        `.replace(/\s+/g, " ");
        const url = overpassUrl + query; //encodeURIComponent(query);
        console.debug(url);
        $.get(url, function(result) {
          console.debug(`Query returned ${result.elements.length} elements`);
          console.debug(result);

          // filter out all platforms and stops of relation (uninteresting or already contained in result.elements, respectively)
          const relation = result.elements.find(elem => elem.type == "relation");
          relation.members = relation.members.filter(member => member.role != "platform" && member.role != "stop");

          const resultAsGeojson = osmtogeojson(result);
          console.debug(resultAsGeojson);

          const resultLayer = L.geoJson(resultAsGeojson, {
            style: function (feature) {
              return { color: "#ff0000" };
            },
            filter: function (feature, layer) {
              // some restaurants may be contained as way/polygon rather than node -> map to point
              const isPolygon = (feature.geometry) && (feature.geometry.type !== undefined) && (feature.geometry.type === "Polygon");
              if (isPolygon) {
                feature.geometry.type = "Point";
                const polygonCenter = L.latLngBounds(feature.geometry.coordinates[0]).getCenter();
                feature.geometry.coordinates = [ polygonCenter.lat, polygonCenter.lng ];
              }
              return true;
            },
            onEachFeature: function (feature, layer) {
              var popupContent = "";
              popupContent = popupContent + "<dt>@id</dt><dd>" + feature.properties.type + "/" + feature.properties.id + "</dd>";
              var keys = Object.keys(feature.properties.tags);
              keys.forEach(function (key) {
                popupContent = popupContent + "<dt>" + key + "</dt><dd>" + feature.properties.tags[key] + "</dd>";
              });
              popupContent = popupContent + "</dl>"
              layer.bindPopup(popupContent);
            }
          }).addTo(map);
        });

      }

      var map = L.map('map').setView([47.376981,8.5405079], 14);
      start();

      L.tileLayer('http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 18,
        attribution: 'Map data &copy; <a href="http://openstreetmap.org/copyright">OpenStreetMap</a> contributors</a>'
      }).addTo(map);

      $("#tram-selector").change(function () {
          const tramId = $("#tram-selector option:selected").val();
          loadRouteAndRestaurants(tramId);
      });
    </script>
  </body>
</html>